---
title: Supscriptions
---

Subscriptions allow clients to receive updates in real time from the server. You can either us Websocket or Server-Sent-Events protocol.

This documentation might use some vocabulary you never had to deal with before:

<u>**Subscription**:</u>
<br />A subscription is a way to listen to real time events. In our case the clients will subscribe
to events coming from our backend.

<u>**Topic**:</u>
<br />A topic (also called channel) is an identifier used to subscribe to specific events. For
example clients that will subscribe to the topic `recipe:created` will only receive the events after
a recipe has been created.

<u>**PubSub**:</u>
<br />A PubSub system is a way to `Publish` and `Subscribe` to different topics. For example you
could use `pubsub.subscribe('recipe:created', callback)` to subscribe to the `recipe:created` topic
and `pubsub.publish('recipe:created', recipe)` to publish a created recipe.

## Configuration

```ts title="config/graphql.ts" twoslash
// @noErrors
import { pubsubs } from '@foadonis/graphql'
import { defineConfig } from '@foadonis/graphql'

export default defineConfig({
  pubSub: pubsubs.native(), // [!code highlight]
})
```

<Callout type='warn'>

In production, you might have multiple instances of your Adonis Application running behind a Load Balancer. Events published on one instance will not be broadcasted to other instances. Please check [Distributed PubSub documentation](#distributed-pubsub).

</Callout>

## Creating Subscriptions

Subscription resolvers are similar to [queries and mutation resolvers](./resolvers). In this example we will allow clients to receive real-time updates every time a new Recipe is created.

In a Resolver class, create a new method decorated with `@Subscription`.

### Single Topic

```ts title="app/graphql/resolvers/recipe_resolver.ts" twoslash
// @noErrors
import { Resolver, Subscription } from '@foadonis/graphql'
import Recipe from '#graphql/recipe'

@Resolver()
export default class RecipeResolver {
  @Subscription({
    topics: 'recipe:created',
  })
  recipeCreated(@Root() payload: Recipe): Recipe {
    return payload
  }
}
```

### Multiple Topics

The `topics` option accepts a list of topics allowing you to subscribe to multiple topics.

```ts title="app/graphql/resolvers/recipe_resolver.ts" twoslash
// @noErrors
import { Resolver, Subscription } from '@foadonis/graphql'
import Recipe from '#models/recipe'
import RecipeEvent from '#graphql/schemas/recipe_event'

@Resolver()
export default class RecipeResolver {
  @Subscription({
    topics: ['recipe:created', 'recipe:deleted'],
  })
  recipe(@Root() payload: RecipeEvent): RecipeEvent {
    return payload
  }
}
```

### Dynamic Topics

The topics option also accept a function that receive the context allowing you to dynamically subscribe to topics.

```ts title="app/graphql/resolvers/recipe_resolver.ts" twoslash
// @noErrors
import { Resolver, Subscription } from '@foadonis/graphql'
import Recipe from '#models/recipe'
import RecipeEvent from '#graphql/schemas/recipe_event'

@Resolver()
export default class RecipeResolver {
  @Subscription({
    topics: ({ args }) => args.topic,
  })
  recipe(@Root() payload: RecipeEvent): RecipeEvent {
    return payload
  }
}
```

### Custom Subscription

The `@Subscription` decorator accepts a `subscribe` parameter allowing you to subscribe to any events using [Async Iterators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncIterator).

For example a common scenario used for real-time applications is to emit an initial empty event and subscribe to different topics to re-send values to the client.

```ts title="app/graphql/resolvers/recipe_resolver.ts" twoslash
import graphql from '@foadonis/graphql/services/main'
import { Resolver, Subscription } from '@foadonis/graphql'
import { Repeater } from '@graphql-yoga/subscription'

// @noErrors
@Resolver()
export default class RecipeResolver {
  @Subscription(() => [Recipe], {
    subscribe: () =>
      Repeater.merge([
        undefined,
        pubsub.subscribe('recipe:created'),
        pubsub.subscribe('recipe:updated'),
      ]),
  })
  @Query(() => [Recipe])
  recipes() {
    return Recipe.all()
  }
}
```

<Callout>

This solution makes it easy to build real-time applications but it comes with a big performance trade-off as recipes will be re-fetched everytime a new one is updated or created.

</Callout>

## Triggering Subscription Topics

Now that we have create our subscriptions, we can use the `PubSub` system to broadcast our events. This will usually be done inside a mutation but you can use it wherever you want inside your application.

### Inside a resolver

```ts title="app/graphql/resolvers/recipe_resolver.ts" twoslash
// @noErrors
import { Resolver, Mutation } from '@foadonis/graphql'
import Recipe from '#models/recipe'
import RecipeEvent from '#graphql/schemas/recipe_event'
import graphql from '@foadonis/graphql/services/main'

@Resolver()
export default class RecipeResolver {
  @Mutation(() => Recipe)
  createRecipe(): RecipeEvent {
    const recipe = Recipe.create()

    graphql.pubSub.publish('recipe:created', new RecipeEvent(recipe, 'created'))

    return recipe
  }
}
```

### Outside a resolver

```ts title="start/routes.ts" twoslash
// @noErrors
import router from '@adonisjs/core/services/router'
import Recipe from '#models/recipe'
import RecipeEvent from '#graphql/schemas/recipe_event'
import graphql from '@foadonis/graphql/services/main'

router.post('/api/recipes', () => {
  const recipe = Recipe.create()

  graphql.pubSub.publish('recipe:created', new RecipeEvent(recipe, 'created'))

  return recipe
})
```

## Typing PubSub Events

Our `PubSub` can already be used as it is but to have proper autocompletion and ensure we always forward proper data it is useful to define what are the different topics.

```ts title="types/pubsub.ts"
declare module '@foadonis/graphql/types' {
  interface PubSubEvents {
    'recipe:created': [Recipe]
    'recipe:deleted': [Recipe]
  }
}
```

## Distributed PubSub

When running multiple instances of your Adonis Application in a distributed environment you need a way to distribute the published event so every instance will notify their subscribers.

```package-install
npm install @graphql-yoga/redis-event-target ioredis
```

```ts title="config/graphql.ts"
import { pubsubs } from '@foadonis/graphql'
import { defineConfig } from '@foadonis/graphql'

export default defineConfig({
  pubSub: pubsubs.redis({
    publish: {
      host: env.get('REDIS_HOST'),
      port: env.get('REDIS_PORT'),
      password: env.get('REDIS_PASSWORD'),
    },
    subscribe: {
      host: env.get('REDIS_HOST'),
      port: env.get('REDIS_PORT'),
      password: env.get('REDIS_PASSWORD'),
    },
  }),
})
```

## Context

When doing Subscriptions over Websocket you need to build your own **Context** as it is not possible to provide an **HttpContext**.

```ts title=config/graphql.ts
import { pubsubs } from '@foadonis/graphql'
import { defineConfig } from '@foadonis/graphql'
import { IncomingMessage } from 'node:http'

export default defineConfig({
  pubSub: pubsubs.native(),
  ws: {
    context: ({ extra }) => {
      return {
        request: extra.request,
      }
    },
  },
})

export type WebsocketContext = {
  request: IncomingMessage
}
```

```ts title="app/graphql/recpie_resolver.ts"
import { Resolver, Subscription, Ctx } from '@foadonis/graphql'
import { WebsocketContext } from '#config/graphql'

export default class RecipesResolver {
  @Subscription({
    topics: ['recipe:created', 'recipe:deleted'],
  })
  recipe(@Root() payload: RecipeEvent, @Ctx() ctx: WebsocketContext): RecipeEvent {
    return payload
  }
}
```

### Authentication

When performing [authentication through WebSocket](https://www.apollographql.com/docs/react/data/subscriptions#5-authenticate-over-websocket-optional) your context method will receive the connection params.

```ts title=config/graphql.ts
import { pubsubs } from '@foadonis/graphql'
import { defineConfig } from '@foadonis/graphql'
import { IncomingMessage } from 'node:http'
import { errors } from '@adonisjs/auth'
import { Secret } from '@adonisjs/core/helpers'
import User from '#models/user'

export default defineConfig({
  pubSub: pubsubs.native(),
  ws: {
    context: ({ extra, connectionParams }) => {
      const token = ctx.connectionParams?.authToken as string | undefined

      if (!token) {
        throw new errors.E_INVALID_CREDENTIALS('Missing credentials')
      }

      const accessToken = await User.accessTokens.verify(new Secret(token))

      if (!accessToken) {
        throw new errors.E_INVALID_CREDENTIALS('Invalid credentials')
      }

      const user = await User.findOrFail(access.tokenableId)

      return {
        request: extra.request,
        user,
      }
    },
  },
})

export type WebsocketContext = {
  request: IncomingMessage
  user: User
}
```
