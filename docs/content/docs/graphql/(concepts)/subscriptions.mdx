---
title: Supscriptions
---

Subscriptions allow clients to receive updates in real time from the server. You can either us Websocket or Server-Sent-Events protocol.

This documentation might use some vocabulary you never had to deal with before:

<u>**Subscription**:</u>
<br />A subscription is a way to listen to real time events. In our case the clients will subscribe
to events coming from our backend.

<u>**Topic**:</u>
<br />A topic (also called channel) is an identifier used to subscribe to specific events. For
example clients that will subscribe to the topic `recipe:created` will only receive the events after
a recipe has been created.

<u>**PubSub**:</u>
<br />A PubSub system is a way to `Publish` and `Subscribe` to different topics. For example you
could use `pubsub.subscribe('recipe:created', callback)` to subscribe to the `recipe:created` topic
and `pubsub.publish('recipe:created', recipe)` to publish a created recipe.

## Configuration

First you will need to install the [@graphql-yoga/subscription](https://the-guild.dev/graphql/yoga-server/docs/features/subscriptions) package.

```package-install
npm i @graphql-yoga/subscription
```

Then configure both the `PubSubDriver` and `Subscription` driver in `config/graphql.ts`.

```ts title="config/graphql.ts" twoslash
// @noErrors
import { defineConfig, drivers } from '@foadonis/graphql'

export default defineConfig({
  // [!code highlight:4]
  pubSub: drivers.pubsub.native(),
  subscription: drivers.subscription.websocket({
    path: '/graphql',
  }),
})
```

<Callout type='warn'>

In production, you might have multiple instances of your Adonis Application running behind a Load Balancer. Events published on one instance will not be broadcasted to other instances. Please check [Distributed PubSub documentation](#distributed-pubsub).

</Callout>

## Creating Subscriptions

Subscription resolvers are similar to [queries and mutation resolvers](./resolvers). In this example we will allow clients to receive real-time updates every time a new Recipe is created.

In a Resolver class, create a new method decorated with `@Subscription`.

### Single Topic

```ts title="app/graphql/resolvers/recipe_resolver.ts" twoslash
// @noErrors
import { Resolver, Subscription } from '@foadonis/graphql'
import Recipe from '#graphql/recipe'

@Resolver()
export default class RecipeResolver {
  @Subscription({
    topics: 'recipe:created',
  })
  recipeCreated(@Root() payload: Recipe): Recipe {
    return payload
  }
}
```

### Multiple Topics

The `topics` option accepts a list of topics allowing you to subscribe to multiple topics.

```ts title="app/graphql/resolvers/recipe_resolver.ts" twoslash
// @noErrors
import { Resolver, Subscription } from '@foadonis/graphql'
import Recipe from '#models/recipe'
import RecipeEvent from '#graphql/schemas/recipe_event'

@Resolver()
export default class RecipeResolver {
  @Subscription({
    topics: ['recipe:created', 'recipe:deleted'],
  })
  recipe(@Root() payload: RecipeEvent): RecipeEvent {
    return payload
  }
}
```

### Dynamic Topics

The topics option also accept a function that receive the context allowing you to dynamically subscribe to topics.

```ts title="app/graphql/resolvers/recipe_resolver.ts" twoslash
// @noErrors
import { Resolver, Subscription } from '@foadonis/graphql'
import Recipe from '#models/recipe'
import RecipeEvent from '#graphql/schemas/recipe_event'

@Resolver()
export default class RecipeResolver {
  @Subscription({
    topics: ({ args }) => args.topic,
  })
  recipe(@Root() payload: RecipeEvent): RecipeEvent {
    return payload
  }
}
```

### Custom Subscription

The `@Subscription` decorator accepts a `subscribe` parameter allowing you to subscribe to any events using [Async Iterators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncIterator).

For example a common scenario used for real-time applications is to emit an initial empty event and subscribe to different topics to re-send values to the client.

```ts title="app/graphql/resolvers/recipe_resolver.ts" twoslash
import graphql from '@foadonis/graphql/services/main'
import { Resolver, Subscription } from '@foadonis/graphql'
import { Repeater } from '@graphql-yoga/subscription'

// @noErrors
@Resolver()
export default class RecipeResolver {
  @Subscription(() => [Recipe], {
    subscribe: () =>
      Repeater.merge([
        undefined,
        pubsub.subscribe('recipe:created'),
        pubsub.subscribe('recipe:updated'),
      ]),
  })
  @Query(() => [Recipe])
  recipes() {
    return Recipe.all()
  }
}
```

<Callout>

This solution makes it easy to build real-time applications but it comes with a big performance trade-off as recipes will be re-fetched everytime a new one is updated or created.

</Callout>

## Triggering Subscription Topics

Now that we have create our subscriptions, we can use the `PubSub` system to broadcast our events. This will usually be done inside a mutation but you can use it wherever you want inside your application.

### Inside a resolver

```ts title="app/graphql/resolvers/recipe_resolver.ts" twoslash
// @noErrors
import { Resolver, Mutation } from '@foadonis/graphql'
import Recipe from '#models/recipe'
import RecipeEvent from '#graphql/schemas/recipe_event'
import graphql from '@foadonis/graphql/services/main'

@Resolver()
export default class RecipeResolver {
  @Mutation(() => Recipe)
  createRecipe(): RecipeEvent {
    const recipe = Recipe.create()

    graphql.pubSub.publish('recipe:created', new RecipeEvent(recipe, 'created'))

    return recipe
  }
}
```

### Outside a resolver

```ts title="start/routes.ts" twoslash
// @noErrors
import router from '@adonisjs/core/services/router'
import Recipe from '#models/recipe'
import RecipeEvent from '#graphql/schemas/recipe_event'
import graphql from '@foadonis/graphql/services/main'

router.post('/api/recipes', () => {
  const recipe = Recipe.create()

  graphql.pubSub.publish('recipe:created', new RecipeEvent(recipe, 'created'))

  return recipe
})
```

## Typing PubSub Events

Our `PubSub` can already be used as it is but to have proper autocompletion and ensure we always forward proper data it is useful to define what are the different topics.

```ts title="types/pubsub.ts"
declare module '@foadonis/graphql/types' {
  interface PubSubEvents {
    'recipe:created': [Recipe]
    'recipe:deleted': [Recipe]
  }
}
```

## Distributed PubSub

When running multiple instances of your Adonis Application in a distributed environment you need a way to distribute the published event so every instance will notify their subscribers.

```package-install
npm install @graphql-yoga/redis-event-target ioredis
```

```ts title="config/graphql.ts"
import { defineConfig, drivers } from '@foadonis/graphql'

export default defineConfig({
  pubSub: drivers.pubsub.redis({
    publish: {
      host: env.get('REDIS_HOST'),
      port: env.get('REDIS_PORT'),
      password: env.get('REDIS_PASSWORD'),
    },
    subscribe: {
      host: env.get('REDIS_HOST'),
      port: env.get('REDIS_PORT'),
      password: env.get('REDIS_PASSWORD'),
    },
  }),
})
```

## Context

When doing Subscriptions over Websocket there is no [ServerResponse](https://nodejs.org/api/http.html#class-httpserverresponse) as once the Weboscket handshake has been performed there is no way to write to the response.

We still create an [HttpContext](https://docs.adonisjs.com/guides/concepts/http-context) containing the initial [Request](https://docs.adonisjs.com/guides/basics/request) and a fake [Response](https://docs.adonisjs.com/guides/basics/response) allowing you to access it inside your resolvers.
**Be aware that you will not be able to use the response.**

```ts
import { Resolver, Subscription, Ctx } from '@foadonis/graphql'
import { HttpContext } from '@adonisjs/core/http'

export default class RecipesResolver {
  @Subscription({
    topics: ['recipe:created', 'recipe:deleted'],
  })
  recipe(@Root() payload: RecipeEvent, @Ctx() ctx: HttpContext): RecipeEvent {
    ctx.request.cookie('my-cookie') // ✅ Works
    ctx.response.cookie('my-cookie', 'new-value') // ❌ Does not work

    return payload
  }
}
```

### Middlewares & Authentication

As we re-create an [HttpContext](https://docs.adonisjs.com/guides/concepts/http-context) you can use the same middlewares you would use on the [HttpRouter](https://docs.adonisjs.com/guides/basics/routing) (minus the response capabilities).

```ts title=start/kernel.ts
import graphql from '@foadonis/graphql/services/main'

graphql.subscription.use([
  () => import('@adonisjs/auth/initialize_auth_middleware'),
  () => import('#middleware/silent_auth_middleware'),
])
```
