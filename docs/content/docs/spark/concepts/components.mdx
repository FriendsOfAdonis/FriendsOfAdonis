---
title: Components
---

Components are the core concept of Spark.

## Rendering components

Spark add JSX support to your Adonis application allowing you to render HTML directly from your routes:

### From routes

You can return JSX directly from your routes or your controllers.
The result will be wrapped into the `rootLayout` configured in `config/spark.ts`.

It is then rendered as HTML and streamed to the client.

```tsx
router.get('/', () => {
  return (
    <div>
      <h1>Hello Spark!</h1>
    </div>
  )
})
```

### Manually

Sometimes you may want to render manually to HTML. Wether it is for using a custom layout or for different usage.
You can create a `Renderer` using the `createRenderer` method.

```tsx
import spark from '@foadonis/spark/services/main'
import MyCustomLayout from '#spark/layouts/my_custom_layout'

const renderer = spark.createRenderer()

const html = await renderer
  .layout(MyCustomLayout)
  .render(<div>Hello</div>)
  .toString()
```

## Function components

Function components are really similar to the one you might already know with [React](https://react.dev/).

```tsx
const ExampleComponent = () => {
  return <div>Hello World!</div>
}

const Demo = () => (
  <div>
    <ExampleComponent />
  </div>
)
```

They can accept props, receive children, className, etc.

```tsx
export const Button = ({
  children,
  className,
  icon,
  ...props
}: ComponentProps<'button'> & { icon?: JSX.Element }) => {
  return (
    <button className={cn('bg-black text-white', className)}>
      {icon} {children}
    </button>
  )
}
```

Function components can also be async, which means that you can fetch data directly from your database.

```tsx
export const UsersList = async () => {
  const users = await User.all()

  return (
    <ul>
      {users.map((user) => (
        <li>{user.name}</li>
      ))}
    </ul>
  )
}
```

## Class components

Class components are similar to [React Class components](https://react.dev/reference/react/Component) but with way more power as they live only on the server, can contain state and server actions.

A Class Component must contain a `render` method wich return JSX to be rendered.

```tsx
export class Button extends BaseComponent {
  render() {
    return <button>Hello World</button>
  }
}
```

Class components live on your server which means that you can safely access your services.
For example you can fetch posts from your database.

```tsx
export class PostsList extends BaseComponent {
  async render() {
    const posts = await Post.findMany()

    return (
      <ul>
        {posts.map((post) => (
          <li>{post.title}</li>
        ))}
      </ul>
    )
  }
}
```

### Props

A server component can receive props by specifing the type `BaseComponent<P>` they are then accessible using `this.props`.

```tsx
export class PageHeader extends BaseComponent<{ title: string }> {
  async render() {
    const posts = await Post.findMany()

    return (
      <h1>{this.props.title}</ul>
    )
  }
}
```

```tsx
<PageHeader title="Hello Spark!" />
```

Similar to React, it is also possible to use the special `children` property:

```tsx
export class PageHeader extends BaseComponent<{ children: string }> {
  async render() {
    const posts = await Post.findMany()

    return (
      <h1>{this.props.children}</ul>
    )
  }
}
```

```tsx
<PageHeader>Hello Spark!</PageHeader>
```

### Actions

Actions are what make Spark extremely powerful. Because even tho components are living on the server, you can still create interactivity.
You an read more about [Actions](./actions) on the dedicated page.

```tsx
export class Counter extends BaseComponent {
  count = 0

  async render() {
    return (
      <div>
        <h1>Counter {this.count}</h1>
        <button $click={this.increment}>Increment</button>
        <button $click={this.decrement}>Decrement</button>
      </div>
    )
  }

  increment() {
    this.count++
  }

  decrement() {
    this.count--
  }
}
```

### Dependency Injection

Components can benefit from the [dependency injection](https://docs.adonisjs.com/guides/concepts/dependency-injection) feature of Adonis.

```tsx
@inject()
export class PageHeader extends BaseComponent {
  constructor(private posts: PostsService) {
    super()
  }

  async render() {
    return (
      <ul>
        {this.posts.map((post) => (
          <li>{post.title}</li>
        ))}
      </ul>
    )
  }
}
```

### Function components

Class components are great when you need two way bindings (models, actions, etc).
But sometimes you might just want to render basic HTML, in this case you can use Function Components.

```tsx
export const Button = ({ children }) => {
  return <button>{children}</button>
}
```

Function components also live on the server and can be async!

```tsx
import Post from '#models/post'

export const PostsList = () => {
  const posts = await Post.findMany()
  return (
    <div>
      <ul>
        {posts.map((post) => (
          <li>{post.title}</li>
        ))}
      </ul>
    </div>
  )
}
```

### HttpContext

You can access the current HttpContext from inside your components.

```tsx
export default class Greeter extends Component {
  async render() {
    const user = this.ctx.auth.getUserOrFail()

    return <h1>Hello {user.name}</h1>
  }
}
```

## Client-side interactivity

Under the hood Spark uses [Alpine.js](https://alpinejs.dev/) to provide client-side interactivity making it available for you as well.

```tsx
export const Username = () => (
  <div x-data="{ username: 'Gaston' }">
    Username: <strong x-text="username"></strong>
  </div>
)
```

### Events

[Alpine.js events feature](https://alpinejs.dev/directives/on) uses a naming that does not work with JSX. Luckily, Spark brings a special syntax to handle this by allowing you to prefix event names with `$` instead of `x-on:`.

```tsx tab="JSX"
<button $click="console.log('Hello World')"></button>
```

```html tab="Result"
<button x-on:click="console.log('Hello World')"></button>
```

You can also use apply [Event modifiers](https://alpinejs.dev/directives/on#modifiers):

```tsx tab="JSX"
<button $click={["console.log('Hello World')", { stop: true, debounce: 500 }]}></button>
```

```html tab="Result"
<button x-on:click.stop.debounce.500ms="console.log('Hello World')"></button>
```
